import numpy as np
import matplotlib.pyplot as plt
from scipy.linalg import expm

# --- 1. System Parameters (Same Dispersive Setup as CPhase) ---
g = 0.05       # Qubit-Qubit coupling strength (GHz)
omega_q = 5.0  # Qubit 1 fixed frequency (GHz)

# Tuning Sweep (Detuning Delta = omega_q2 - omega_q1)
flux_points = np.linspace(-0.5, 0.5, 300)
omega_q2_sweep = omega_q + flux_points * 0.5
detuning_sweep = omega_q2_sweep - omega_q

# Optimal CPhase detuning (far from resonance)
DELTA_CPHASE = -0.25
chi_cphase = g**2 / DELTA_CPHASE          # Effective ZZ-shift
T_CNOT = np.pi / np.abs(chi_cphase)       # Time required for the internal CZ gate (T_CNOT = T_CPHASE)

# --- 2. Target Unitaries and Synthesis Operators ---

# Target CNOT Gate (Control Q1, Target Q2)
U_cnot_target = np.array([
    [1, 0, 0, 0],
    [0, 1, 0, 0],
    [0, 0, 0, 1],
    [0, 0, 1, 0]
], dtype=complex)

# Target CZ Gate (Internal gate)
U_cz_target = np.diag([1, 1, 1, -1])

# Hadamard Gate
H = 1/np.sqrt(2) * np.array([[1, 1], [1, -1]])
# Identity operator
I = np.eye(2)
# Rotation operator (I tensor H) applied before and after CZ
U_hadamard_rot = np.kron(I, H)

# --- 3. Simulation Functions ---

def calculate_effective_chi(delta, g_val):
    """Calculates the effective ZZ-coupling rate (chi) in the dispersive regime (approximation)."""
    if np.abs(delta) < 1e-6:
        return 0.0
    return g_val**2 / delta

def get_full_two_qubit_hamiltonian(delta, g_val):
    """Returns the full two-qubit Hamiltonian in the rotating frame."""
    H_diag = np.diag([
        -delta/2 - delta/2, # |00>
        -delta/2 + delta/2, # |01>
        +delta/2 - delta/2, # |10>
        +delta/2 + delta/2  # |11>
    ])
    H_int = np.zeros((4, 4), dtype=complex)
    H_int[1, 2] = g_val
    H_int[2, 1] = g_val
    return H_diag + H_int

def calculate_cnot_fidelity(delta, g_val, t):
    """Calculates the CNOT gate fidelity F(t) synthesized from the evolving CZ gate."""
    H = get_full_two_qubit_hamiltonian(delta, g_val)

    # 1. Evolving CZ Unitary (U_CZ(t))
    # Note: U_CZ(t) is the actual evolution generated by the Hamiltonian H.
    E, V = np.linalg.eigh(H)
    U_cz_simulated = V @ np.diag(np.exp(-1j * E * t)) @ V.T.conj()

    # 2. Synthesize CNOT: U_CNOT(t) = (I x H) * U_CZ(t) * (I x H)
    U_cnot_simulated = U_hadamard_rot @ U_cz_simulated @ U_hadamard_rot

    # 3. Calculate Fidelity F(t) = |Trace(U_target * U_simulated^dagger)| / dim
    U_cnot_dagger = U_cnot_simulated.conj().T
    fidelity = np.abs(np.trace(U_cnot_target @ U_cnot_dagger)) / 4.0

    # 4. Conditional Phase (for plot b)
    phi_00 = np.angle(U_cz_simulated[0, 0])
    phi_11 = np.angle(U_cz_simulated[3, 3])
    conditional_phase_wrapped = (phi_11 - phi_00) % (2 * np.pi)
    if conditional_phase_wrapped < 0:
        conditional_phase_wrapped += 2 * np.pi
        
    return conditional_phase_wrapped, fidelity

# --- 4. Plotting ---
fig, axes = plt.subplots(1, 3, figsize=(18, 6))
plt.style.use('seaborn-v0_8-darkgrid')
plt.rcParams['font.family'] = 'Inter'

# --- (a) Dispersive Shift (No Change) ---
ax1 = axes[0]
chi_vals = [calculate_effective_chi(d, g) for d in detuning_sweep]
# Use the same plotting function for chi (from the CPHASE dynamics)
ax1.plot(detuning_sweep, chi_vals, color='#FF7F0E')
ax1.set_title('(a) Dispersive Frequency Shift $\chi_{12}$', fontsize=14)
ax1.set_xlabel(r'Detuning $\Delta = \omega_{q2} - \omega_{q1}$ (GHz)', fontsize=12)
ax1.set_ylabel(r'Conditional Shift $\chi_{12}$ (GHz)', fontsize=12)
ax1.axvline(x=DELTA_CPHASE, color='r', linestyle='--', linewidth=1.5)
ax1.text(DELTA_CPHASE * 1.05, ax1.get_ylim()[1] * 0.9, r'$\Delta_{\text{CNOT}}$', color='r', ha='left')
ax1.grid(True, linestyle=':', alpha=0.6)
ax1.spines['top'].set_visible(False)
ax1.spines['right'].set_visible(False)

# --- (b) Conditional Phase vs. Detuning and Time (Wrapped Phase for Heatmap) ---
ax2 = axes[1]
time_steps = np.linspace(0, 2 * T_CNOT, 200)
phase_data = np.zeros((len(time_steps), len(detuning_sweep)))

for i, t in enumerate(time_steps):
    for j, delta in enumerate(detuning_sweep):
        if np.abs(delta) < 0.005 and t > 0.1 * T_CNOT:
             phase_data[i, j] = np.nan
             continue

        wrapped_phase, _ = calculate_cnot_fidelity(delta, g, t)
        phase_data[i, j] = wrapped_phase

normalized_time = time_steps / T_CNOT
normalized_time_ticks = [0, 0.5, 1.0, 1.5, 2.0]

im = ax2.imshow(phase_data, aspect='auto', origin='lower',
                extent=[detuning_sweep.min(), detuning_sweep.max(), normalized_time.min(), normalized_time.max()],
                cmap='viridis', vmin=0, vmax=2*np.pi)

ax2.set_yticks(normalized_time_ticks)
ax2.set_yticklabels([r'$0$', r'$\tau_{\text{CNOT}}/2$', r'$\tau_{\text{CNOT}}$', r'$3\tau_{\text{CNOT}}/2$', r'$2\tau_{\text{CNOT}}$'])
ax2.set_title('(b) Conditional Phase $\phi$ vs. Detuning and Time (Underlying CZ)', fontsize=14)
ax2.set_xlabel(r'Detuning $\Delta$ (GHz)', fontsize=12) 
ax2.set_ylabel(r'Time, $t$ (Normalized to $\tau_{\text{CNOT}}$)', fontsize=12) 
ax2.axvline(x=DELTA_CPHASE, color='w', linestyle='--', linewidth=2)
ax2.axhline(y=1.0, color='w', linestyle=':', linewidth=1.5)
cbar = fig.colorbar(im, ax=ax2, orientation='vertical', pad=0.04)
cbar.set_label(r'Accumulated Phase $\phi$ (rad)', fontsize=12)
ax2.spines['top'].set_visible(False)
ax2.spines['right'].set_visible(False)


# --- (c) CNOT Gate Fidelity vs. Time at Optimal Detuning ---
ax3 = axes[2]

# Simulation over time at optimal point
fidelities_cnot = []
phases_cnot = []
for t in time_steps:
    phase, fidelity = calculate_cnot_fidelity(DELTA_CPHASE, g, t)
    fidelities_cnot.append(fidelity)
    phases_cnot.append(phase) # Keep this for reference plot

# Plot CNOT Fidelity (This is the primary CNOT result)
ax3.plot(normalized_time, fidelities_cnot, color='#2CA02C', linestyle='-', label='CNOT Gate Fidelity $F(t)$')

# Plot Conditional Phase (for comparison with target pi)
ax3.plot(normalized_time, phases_cnot, color='#1F77B4', linestyle='--', label='Underlying CZ Phase $\phi$')

# Mark the CNOT time (where CZ phase is pi and CNOT fidelity peaks)
ax3.axvline(x=1.0, color='r', linestyle='--', linewidth=1.5)
ax3.axhline(y=1.0, color='#2CA02C', linestyle=':', linewidth=1) # Target Fidelity = 1.0
ax3.axhline(y=np.pi, color='#1F77B4', linestyle=':', linewidth=1) # Target CZ Phase = pi

ax3.set_title('(c) CNOT Fidelity & Phase at $\Delta_{\text{CNOT}}$', fontsize=14)
ax3.set_xlabel(r'Time, $t$ (Normalized to $\tau_{\text{CNOT}}$)', fontsize=12) 
ax3.set_ylabel(r'Value (Fidelity or Phase/rad)', fontsize=12) 
ax3.set_xticks(normalized_time_ticks)
ax3.set_xticklabels([r'$0$', r'$\tau_{\text{CNOT}}/2$', r'$\tau_{\text{CNOT}}$', r'$3\tau_{\text{CNOT}}/2$', r'$2\tau_{\text{CNOT}}$'])
ax3.set_ylim(0, 4.0) # Set a reasonable limit to show both phase and fidelity

ax3.legend(loc='upper left', fontsize=10)
ax3.spines['top'].set_visible(False)
ax3.spines['right'].set_visible(False)


plt.tight_layout()
plt.show()

print(f"--- CNOT Gate Simulation Parameters ---")
print(f"Coupling strength (g): {g:.3f} GHz")
print(f"Optimal Detuning (Delta_CNOT): {DELTA_CPHASE:.3f} GHz")
print(f"Effective ZZ-shift (|chi|): {np.abs(chi_cphase):.3f} GHz")
print(f"Target Gate Time (T_CNOT): {T_CNOT:.3f} Units")